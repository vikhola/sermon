# Validation
The @vikhola/sermon validation provides logger message validation. This is first stage of message processing. The message validation executes inside the channel or logger instances, takes a payload, and return result of validation, false if validation was failed and true if successful.

## Initialize 
The initialization of logger validator is easy and it constructor doesn`t accept any parameters.
```js
const theValidator = new LoggerValidator()
```

## Handlers
Result of validation decides handlers pipeline where if one of handlers return false validation will be failed and message ignored. To add handlers to the validation pipeline uses set method.
```js
function handler(message) {}
const theValidator = new LoggerValidator()
theValidator.set("handler", handler)
```
By default validator already has several validation handlers, but all of them work only with the logger messages. This is mean that only the logger messages will be validated, the other payload will return true and validation will not fail. 

- The key `level` has a handler which check message level and if the this context contain it, return true, otherwise false.

	```js
const theValidator = new LoggerValidator()
const theConsoleChannel = new LoggerConsoleChannel({
	validator:  theValidator, 
	levels: ErrorLevel
})
const theMessage = new LoggerMessage({level: DebugLevel})
theConsoleChannel.write(theMessage)
	```
- The key `pub` has a handler which check message publisher and if it doesn`t match with the this id, return true, otherwise false.

	```js
const theValidator = new LoggerValidator()
const theConsoleChannel = new LoggerConsoleChannel({
	validator: theValidator
})
const theMessage = new LoggerMessage({level: DebugLevel, pub: theConsoleChannel.id})
theConsoleChannel.write(theMessage)
	```

Every handler under validation get current channel or logger to it context under pipeline execution. Except anonymous handlers.
```js
const context = {group: "group"}
function handler(message) {
	console.log(this.context.group)
}
const theValidator = new LoggerValidator()
theValidator.set("handler", handler)
const theConsoleChannel = new LoggerConsoleChannel({context, validator: theValidator})
theConsoleChannel.write("some message")
```
In the validation pipeline every handler will get message which should be validated in his argument.
```js
const context = {message: "some message"}
function handler(message) {
	return this.message === message
}
const theValidator = new LoggerValidator()
theValidator.set("handler", handler)
const theConsoleChannel = new LoggerConsoleChannel({context, validator: theValidator})
theConsoleChannel.write("some message")
```

## Logger
The validation of the logger deal by the current logger validator instance. Validation starts when the logger receive message, both as standalone or relay. The logger validation could be used in wide range of things and depended of how the logger instance used. For base standalone way validation could check custom message props.
```js
function handler(message) {
	return message?.group === "console" 
}

const theValidator = new LoggerValidator()
theValidator.set("group", handler)
const theLogger = new Logger({ validator: theValidator })
const theConsoleChannel = new LoggerConsoleChannel()
theLogger.addChannel(theConsoleChannel)
theLogger.info("file message", {group: "file"}) // ignored
theLogger.info("console message", {group: "console"}) 
```
The logger used in relay mode do the same work as standalone instance, except that the focus of validation goes beyond the validation of messages generated by the level writing methods or custom messages from write method to the validation of logger messages. This is allow to, like example, to create groups of channel with one validation rule but don\`t add it to them.
```js
function validationRule(message) {
	return message.get("group") === this.context.group 
}

const theMainLogger = new Logger()
const theValidator = new LoggerValidator()
theValidator.set("group", validationRule)
const theRelayLogger = new Logger({context: {group: "console"}, validator: theValidator})
const theConsoleChannel = new LoggerConsoleChannel()
theMainLogger.addChannel(theRelayLogger)
theRelayLogger.addChannel(theConsoleChannel)
theMainLogger.info("file message", {group: "file"}) // ignored
theMainLogger.info("console message", {group: "console"})
```

## Channel
A channel validation can be used in the same way as a logger relay to create groups of channels with a single group, but with one exception, the channels now forms the groups, not the relay logger, etc.
```js
function handler(message) {
	return message.get("group") === "console" 
}

const theValidator = new LoggerValidator()
theValidator.set("group", handler)
const theLogger = new Logger()
const theConsoleChannel = new LoggerConsoleChannel({validator: theValidator})
theLogger.addChannel(theConsoleChannel)
theLogger.info("my message", {group: "file"}) // will be ignored
```